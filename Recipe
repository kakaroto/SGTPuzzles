# -*- makefile -*-
# 
# This file describes which puzzle binaries are made up from which
# object and resource files. It is processed into the various
# Makefiles by means of a Perl script. Makefile changes should
# really be made by editing this file and/or the Perl script, not
# by editing the actual Makefiles.

!name puzzles

!makefile gtk Makefile
!makefile vc Makefile.vc
!makefile wce Makefile.wce
!makefile cygwin Makefile.cyg
!makefile osx Makefile.osx
!makefile nestedvm Makefile.nestedvm
!makefile ps3 Makefile.ps3

!srcdir icons/
!srcdir ps3/

WINDOWS_COMMON = printing
         + user32.lib gdi32.lib comctl32.lib comdlg32.lib winspool.lib
WINDOWS  = windows WINDOWS_COMMON
COMMON   = midend drawing misc malloc random version
GTK      = gtk printing ps
PS3	 = ps3 ps3drawingapi rsxutil ps3menu printing ps

# Objects needed for auxiliary command-line programs.
STANDALONE = nullfe random misc malloc

ALL      = list

# First half of list.c.
!begin >list.c
/*
 * list.c: List of pointers to puzzle structures, for monolithic
 * platforms.
 *
 * This file is automatically generated by mkfiles.pl. Do not edit
 * it directly, or the changes will be lost next time mkfiles.pl runs.
 * Instead, edit Recipe and/or its *.R subfiles.
 */
#include "puzzles.h"
#define GAMELIST(A) \
!end

# Now each .R file adds part of the macro definition of GAMELIST to list.c.
!include *.R

# Then we finish up list.c as follows:
!begin >list.c

#define DECL(x) extern const game x;
#define REF(x) &x,
#define STR_LIST(x) STR(x),

GAMELIST(DECL)

const game *gamelist[] = { GAMELIST(REF) };
const int gamecount = lenof(gamelist);
const char *gamelist_names[] = { GAMELIST(STR_LIST) };
!end

# Unix standalone application for special-purpose obfuscation.
obfusc : [U] obfusc STANDALONE

puzzles  : [G] windows[COMBINED] WINDOWS_COMMON COMMON ALL noicon.res

Puzzles  : [PS] foo.c bar.c PS3 COMMON ALL

# Mac OS X unified application containing all the puzzles.
Puzzles  : [MX] osx osx.icns osx-info.plist COMMON ALL
# For OS X, we must create the online help and include it in the
# application bundle.) Also we add -DCOMBINED to the compiler flags
# so as to inform the code that we're building a single binary for
# all the puzzles. Then I've also got some code in here to build a
# distributable .dmg disk image.
!begin osx
Puzzles_extra = Puzzles.app/Contents/Resources/Help/index.html
Puzzles.app/Contents/Resources/Help/index.html: \
	Puzzles.app/Contents/Resources/Help osx-help.but puzzles.but
	cd Puzzles.app/Contents/Resources/Help; \
		halibut --html ../../../../osx-help.but ../../../../puzzles.but
Puzzles.app/Contents/Resources/Help: Puzzles.app/Contents/Resources
	mkdir -p Puzzles.app/Contents/Resources/Help

release: Puzzles.dmg
Puzzles.dmg: Puzzles
	rm -f raw.dmg
	hdiutil create -megabytes 5 -layout NONE raw.dmg
	hdid -nomount raw.dmg > devicename
	newfs_hfs -v "Simon Tatham's Puzzle Collection" `cat devicename`
	hdiutil eject `cat devicename`
	hdid raw.dmg | cut -f1 -d' ' > devicename
	cp -R Puzzles.app /Volumes/"Simon Tatham's Puzzle Collection"
	hdiutil eject `cat devicename`
	rm -f Puzzles.dmg
	hdiutil convert -format UDCO raw.dmg -o Puzzles.dmg
	rm -f raw.dmg devicename
!end

# Version management.
!begin vc
version.obj: *.c *.h
	cl $(VER) $(CFLAGS) /c version.c
!end
!specialobj vc version
!begin wce
version.obj: *.c *.h
	$(CC) $(VER) $(CFLAGS) /c version.c
!end
!specialobj wce version
!begin cygwin
version.o: FORCE;
FORCE:
	$(CC) $(COMPAT) $(XFLAGS) $(CFLAGS) $(VER) -c version.c
!end
!specialobj cygwin version
# For Unix, we also need the gross MD5 hack that causes automatic
# version number selection in release source archives.
!begin gtk
version.o: version.c version2.def
	$(CC) $(COMPAT) $(XFLAGS) $(CFLAGS) `cat version2.def` -c version.c
version2.def: FORCE
	if test -z "$(VER)" && test -f manifest && md5sum -c manifest; then \
		cat version.def > version2.def.new; \
	elif test -z "$(VER)" && test -d .svn && svnversion . >/dev/null 2>&1; then \
		echo "-DREVISION=`svnversion .`" >version2.def.new; \
	else \
		echo "$(VER)" >version2.def.new; \
	fi && \
	if diff -q version2.def.new version2.def; then \
		rm version2.def.new; \
	else \
		mv version2.def.new version2.def; \
	fi
.PHONY: FORCE
!end
!specialobj gtk version
!begin nestedvm
version.o: version.c version2.def
	$(CC) $(COMPAT) $(XFLAGS) $(CFLAGS) `cat version2.def` -c version.c
version2.def: FORCE
	if test -z "$(VER)" && test -f manifest && md5sum -c manifest; then \
		cat version.def > version2.def.new; \
	elif test -z "$(VER)" && test -d .svn && svnversion . >/dev/null 2>&1; then \
		echo "-DREVISION=`svnversion .`" >version2.def.new; \
	else \
		echo "$(VER)" >version2.def.new; \
	fi && \
	if diff -q version2.def.new version2.def; then \
		rm version2.def.new; \
	else \
		mv version2.def.new version2.def; \
	fi
.PHONY: FORCE
!end
!specialobj nestedvm version
# For OS X, this is made more fiddly by the fact that we don't have
# md5sum readily available. We do, however, have `md5 -r' which
# generates _nearly_ the same output, but it has no check function.
!begin osx
version.ppc.o: version.c version2.def
	$(CC) -arch ppc $(COMPAT) $(XFLAGS) $(CFLAGS) `cat version2.def` -c version.c -o $@
version.i386.o: version.c version2.def
	$(CC) -arch i386 $(COMPAT) $(XFLAGS) $(CFLAGS) `cat version2.def` -c version.c -o $@
version2.def: FORCE
	if test -z "$(VER)" && test -f manifest && (md5 -r `awk '{print $$2}' manifest` | diff -w manifest -); then \
		cat version.def > version2.def.new; \
	elif test -z "$(VER)" && test -d .svn && svnversion . >/dev/null 2>&1; then \
		echo "-DREVISION=`svnversion .`" >version2.def.new; \
	else \
		echo "$(VER)" >version2.def.new; \
	fi && \
	if diff -q version2.def.new version2.def; then \
		rm version2.def.new; \
	else \
		mv version2.def.new version2.def; \
	fi
.PHONY: FORCE
!end
!specialobj osx version

# make install for Unix.
!begin gtk
install:
	for i in $(GAMES); do \
		$(INSTALL_PROGRAM) -m 755 $$i $(DESTDIR)$(gamesdir)/$$i \
		|| exit 1; \
	done
!end
!begin nestedvm
.PRECIOUS: %.class
%.class: %.mips
	java -cp $(NESTEDVM)/build:$(NESTEDVM)/upstream/build/classgen/build \
		org.ibex.nestedvm.Compiler -outformat class -d . \
		PuzzleEngine $<
		mv PuzzleEngine.class $@

org:
	mkdir -p org/ibex/nestedvm/util
	cp $(NESTEDVM)/build/org/ibex/nestedvm/{Registers,UsermodeConstants,Runtime*}.class org/ibex/nestedvm
	cp $(NESTEDVM)/build/org/ibex/nestedvm/util/{Platform*,Seekable*}.class org/ibex/nestedvm/util
	echo "Main-Class: PuzzleApplet" >applet.manifest

PuzzleApplet.class: PuzzleApplet.java org
	javac -source 1.3 -target 1.3 PuzzleApplet.java

%.jar: %.class PuzzleApplet.class org
	mv $< PuzzleEngine.class
	jar cfm $@ applet.manifest PuzzleEngine.class PuzzleApplet*.class org
	echo '<applet archive="'$@'" code="PuzzleApplet" width="700" height="500"></applet>' >$*.html
	mv PuzzleEngine.class $<
!end


!begin ps3
#---------------------------------------------------------------------------------
# Clear the implicit built in rules
#---------------------------------------------------------------------------------
.SUFFIXES:
#---------------------------------------------------------------------------------
ifeq ($(strip $(PSL1GHT)),)
$(error "Please set PSL1GHT in your environment. export PSL1GHT=<path>")
endif

include $(PSL1GHT)/ppu_rules

TITLE           :=      SGT Puzzles
APPID           :=      SGTPZL010
CONTENTID       :=      UP0001-$(APPID)_00-0000000000000000
SFOXML          :=      $(CURDIR)/ps3/sfo.xml
ICON0           :=      $(CURDIR)/ps3/ICON0.PNG

#---------------------------------------------------------------------------------
# TARGET is the name of the output
# BUILD is the directory where object files & intermediate files will be placed
# SOURCES is a list of directories containing source code
# INCLUDES is a list of directories containing extra header files
#---------------------------------------------------------------------------------
TARGET          :=      Puzzles
PKGFILES        :=      $(CURDIR)/ps3/data
INCLUDES        :=      $(CURDIR)/ps3/ $(CURDIR)
BUILDDIR	:=	.
#---------------------------------------------------------------------------------

#-----------------------------------------------------------
# any extra libraries we wish to link with the project
#-----------------------------------------------------------
LIBS    :=      -lgcm_sys -lrsx -lsysutil -lio -lcairo -lpng -lm -lfreetype -lz -lpixman-1 -lrt -llv2
#-----------------------------------------------------------
# list of directories containing libraries, this must be the top level containing
# include and lib
#-----------------------------------------------------------
LIBDIRS := $(PORTLIBS)

LD = $(CC)

#---------------------------------------------------------------------------------
# build a list of include paths
#---------------------------------------------------------------------------------
INCLUDE  	:=      $(foreach dir,$(INCLUDES), -I$(CURDIR)/$(dir)) \
                                        $(foreach dir,$(LIBDIRS),-I$(dir)/include) \
                                        $(LIBPSL1GHT_INC)

#---------------------------------------------------------------------------------
# build a list of library paths
#---------------------------------------------------------------------------------
LIBPATHS :=      $(foreach dir,$(LIBDIRS),-L$(dir)/lib) \
                                        $(LIBPSL1GHT_LIB)
DEPSDIR  :=      $(CURDIR)

.PHONY: $(TARGET) all clean

$(TARGET): $(TARGET).elf $(TARGET).self

#---------------------------------------------------------------------------------
all: $(TARGET)

run:
	ps3load $(TARGET).self

pkg: all $(TARGET).pkg

clean:
	rm -f *.o $(TARGET).elf $(TARGET).self

%.pkg: %.self
	mkdir -p pkg/USRDIR
	cp $(ICON0) pkg/
	$(SELF_NPDRM) $(basename $<).elf pkg/USRDIR/EBOOT.BIN $(CONTENTID) >> /dev/null
	$(SFO) --title "$(TITLE)" --appid "$(APPID)" -f $(SFOXML) pkg/PARAM.SFO
	if test -n "$(PKGFILES)" -a -d "$(PKGFILES)"; then cp -rf $(PKGFILES)/ pkg/USRDIR/; fi
	$(PKG) --contentid $(CONTENTID) pkg/ $@ >> /dev/null
	cp $@ $(basename $@).geohot.pkg
	$(PACKAGE_FINALIZE) $(basename $@).geohot.pkg
	rm -fr pkg

#---------------------------------------------------------------------------------



!end
